from __future__ import annotations

import os
from pathlib import Path
from typing import Optional, Dict, Any, List

import asyncpg

# ──────────────────────────────────────────────
# GLOBALS
# ──────────────────────────────────────────────

POOL: Optional[asyncpg.Pool] = None
DATABASE_URL = (os.getenv("DATABASE_URL") or "").strip()


# ──────────────────────────────────────────────
# GET POOL
# ──────────────────────────────────────────────

async def get_pool() -> asyncpg.Pool:
    global POOL
    if POOL is None:
        if not DATABASE_URL:
            raise RuntimeError("DATABASE_URL is not set")
        POOL = await asyncpg.create_pool(
            DATABASE_URL,
            min_size=1,
            max_size=5,
        )
    return POOL


# ──────────────────────────────────────────────
# MINIMAL BASE SCHEMA (players)
# ──────────────────────────────────────────────

async def ensure_min_schema() -> None:
    """Ensure the minimum required schema exists.

    Important: must be idempotent and safe for production.

    We keep players.tg_id as the primary key because the whole codebase uses it.
    For "browser only" accounts we generate a high-range tg_id and store Telegram id
    in players.telegram_id.
    """

    pool = await get_pool()
    async with pool.acquire() as conn:
        await conn.execute(
            """
            CREATE TABLE IF NOT EXISTS players (
              tg_id       BIGINT PRIMARY KEY,
              name        TEXT UNIQUE NOT NULL,
              gender      TEXT,
              race_key    TEXT,
              class_key   TEXT,
              level       INT DEFAULT 1,
              xp          INT DEFAULT 0,
              chervontsi  INT DEFAULT 0,
              kleynody    INT DEFAULT 0
            );

            CREATE INDEX IF NOT EXISTS idx_players_name_lower
              ON players ((lower(name)));
            """
        )

        
        # Some newer tables use players.id as a stable FK target.
        # We add it as an identity column for compatibility and backfill for existing rows.
        await conn.execute("""ALTER TABLE players ADD COLUMN IF NOT EXISTS id BIGINT GENERATED BY DEFAULT AS IDENTITY;""")
        await conn.execute("""UPDATE players SET id = DEFAULT WHERE id IS NULL;""")
        await conn.execute("""CREATE UNIQUE INDEX IF NOT EXISTS ux_players_id ON players (id);""")

        # Auth/linking columns (safe additive changes)
        await conn.execute("""ALTER TABLE players ADD COLUMN IF NOT EXISTS telegram_id BIGINT;""")
        await conn.execute("""ALTER TABLE players ADD COLUMN IF NOT EXISTS login TEXT;""")
        await conn.execute("""ALTER TABLE players ADD COLUMN IF NOT EXISTS password_hash TEXT;""")
        await conn.execute("""ALTER TABLE players ADD COLUMN IF NOT EXISTS locale TEXT DEFAULT 'uk';""")

        # Uniques with partial indexes (safe)
        await conn.execute(
            """CREATE UNIQUE INDEX IF NOT EXISTS ux_players_telegram_id
               ON players (telegram_id) WHERE telegram_id IS NOT NULL;"""
        )
        await conn.execute(
            """CREATE UNIQUE INDEX IF NOT EXISTS ux_players_login_lower
               ON players ((lower(login))) WHERE login IS NOT NULL;"""
        )


# ──────────────────────────────────────────────
# MIGRATIONS (db/migrations) with tracking
# ──────────────────────────────────────────────

async def _migrations_dir() -> Path:
    base_dir = Path(__file__).resolve().parent
    return base_dir / "db" / "migrations"


async def _ensure_migrations_table(conn: asyncpg.Connection) -> None:
    await conn.execute(
        """
        CREATE TABLE IF NOT EXISTS schema_migrations (
          name TEXT PRIMARY KEY,
          applied_at TIMESTAMPTZ NOT NULL DEFAULT now()
        );
        """
    )


async def _db_has_user_tables(conn: asyncpg.Connection) -> bool:
    # Any non-system table except schema_migrations
    row = await conn.fetchrow(
        """
        SELECT 1
        FROM information_schema.tables
        WHERE table_schema='public'
          AND table_type='BASE TABLE'
          AND table_name NOT IN ('schema_migrations')
        LIMIT 1;
        """
    )
    return bool(row)


async def _baseline_mark_all(conn: asyncpg.Connection, names: List[str]) -> None:
    # Mark current migration files as applied without executing them.
    # This prevents production crashes if the DB already has the schema.
    if not names:
        return
    values = [(n,) for n in names]
    await conn.executemany(
        """INSERT INTO schema_migrations (name) VALUES ($1) ON CONFLICT DO NOTHING;""",
        values,
    )


async def run_migrations() -> None:
    """Apply SQL files from db/migrations.

    P0 fix: the previous implementation executed every migration on every start.
    Many migrations are NOT idempotent (plain CREATE TABLE), so that approach would
    crash on the second start. We now track applied migrations.

    To avoid breaking an existing production DB that already has tables but never
    had schema_migrations tracking, we auto-baseline: if the DB has tables and
    schema_migrations is empty, we mark existing files as applied.

    Fresh DBs still run migrations normally.
    """

    if not DATABASE_URL:
        print("run_migrations: DATABASE_URL not set")
        return

    migrations_path = await _migrations_dir()
    if not migrations_path.is_dir():
        print("run_migrations: folder not found:", migrations_path)
        return

    files = sorted(p for p in migrations_path.glob("*.sql"))
    if not files:
        print(f"run_migrations: no *.sql files in {migrations_path}")
        return

    pool = await get_pool()
    async with pool.acquire() as conn:
        await _ensure_migrations_table(conn)

        applied = {r["name"] for r in await conn.fetch("SELECT name FROM schema_migrations")}

        # Auto-baseline for existing DBs without migration tracking.
        if not applied and await _db_has_user_tables(conn):
            names = [p.name for p in files]
            await _baseline_mark_all(conn, names)
            print(f"[MIGRATION] baseline marked {len(names)} files as applied")
            return

        for path in files:
            if path.name in applied:
                continue

            sql = path.read_text(encoding="utf-8").strip()
            if not sql:
                print(f"[MIGRATION] {path.name} — empty, skipped")
                await conn.execute(
                    "INSERT INTO schema_migrations (name) VALUES ($1) ON CONFLICT DO NOTHING",
                    path.name,
                )
                continue

            print(f"[MIGRATION] Applying {path.name} ...")
            try:
                async with conn.transaction():
                    await conn.execute(sql)
                    await conn.execute(
                        "INSERT INTO schema_migrations (name) VALUES ($1)",
                        path.name,
                    )
            except Exception as e:
                print(f"[MIGRATION] ERROR in {path.name}: {e}")
                raise

    print("[MIGRATION] All pending migrations applied successfully.")


# ──────────────────────────────────────────────
# FETCH PLAYER
# ──────────────────────────────────────────────

async def fetch_player_by_tg(tg_id: int) -> Dict[str, Any] | None:
    pool = await get_pool()
    async with pool.acquire() as conn:
        row = await conn.fetchrow("SELECT * FROM players WHERE tg_id=$1", int(tg_id))
        return dict(row) if row else None


async def fetch_player_by_telegram_id(telegram_id: int) -> Dict[str, Any] | None:
    """Find player by Telegram user id (miniapp/widget)."""
    await ensure_min_schema()
    pool = await get_pool()
    async with pool.acquire() as conn:
        row = await conn.fetchrow(
            """
            SELECT * FROM players
            WHERE telegram_id=$1 OR tg_id=$1
            LIMIT 1
            """,
            int(telegram_id),
        )
        if not row:
            return None

        d = dict(row)
        # Backfill telegram_id if legacy row uses tg_id=telegram_id
        if d.get("telegram_id") is None:
            try:
                await conn.execute(
                    "UPDATE players SET telegram_id=$1 WHERE tg_id=$2 AND telegram_id IS NULL",
                    int(telegram_id),
                    int(d["tg_id"]),
                )
            except Exception:
                pass
        return d
